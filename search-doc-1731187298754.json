{"searchDocs":[{"title":"5. Conditionals","type":0,"sectionRef":"#","url":"/docs/docs/concepts/conditionals","content":"5. Conditionals","keywords":"","version":"latest"},{"title":"6. Imports","type":0,"sectionRef":"#","url":"/docs/docs/concepts/imports","content":"6. Imports Imports ...","keywords":"","version":"latest"},{"title":"8. Managing State","type":0,"sectionRef":"#","url":"/docs/docs/concepts/managing-state","content":"8. Managing State Validation","keywords":"","version":"latest"},{"title":"FAQ","type":0,"sectionRef":"#","url":"/docs/docs/faq","content":"FAQ","keywords":"","version":"latest"},{"title":"1. ResourceGroups","type":0,"sectionRef":"#","url":"/docs/docs/concepts/resource-groups","content":"","keywords":"","version":"latest"},{"title":"What is a ResourceGroup?​","type":1,"pageTitle":"1. ResourceGroups","url":"/docs/docs/concepts/resource-groups#what-is-a-resourcegroup","content":" A ResourceGroup is a custom resource that serves as a blueprint for creating and managing a collection of Kubernetes resources. It allows you to:  Define multiple resources in a single, cohesive unitEstablish relationships and dependencies between resourcesCreate high-level abstractions of complex Kubernetes configurationsPromote reusability and consistency across your infrastructure  ","version":"latest","tagName":"h2"},{"title":"Anatomy of a ResourceGroup​","type":1,"pageTitle":"1. ResourceGroups","url":"/docs/docs/concepts/resource-groups#anatomy-of-a-resourcegroup","content":" A ResourceGroup, like any Kubernetes resource, consists of three main parts:  Metadata: Name, namespace, labels, etc.Spec: Defines the structure and properties of the ResourceGroupStatus: Reflects the current state of the ResourceGroup  The spec section of a ResourceGroup typically includes:  Parameters: Define the customizable aspects of the ResourceGroupResources: Specify the Kubernetes resources to be createdThe kind and apiVersion fields within the spec define the CRD that will be generated for this ResourceGroup. Here's a simple example of a ResourceGroup:  simple-web-app.yaml apiVersion: kro.run/v1 kind: ResourceGroup metadata: name: simple-web-app spec: kind: SimpleWebApp apiVersion: v1alpha1 parameters: appName: string image: string replicas: int resources: - name: deployment definition: apiVersion: apps/v1 kind: Deployment metadata: name: ${schema.spec.appName}-deployment spec: replicas: ${schema.spec.replicas} selector: matchLabels: app: ${schema.spec.appName} template: metadata: labels: app: ${schema.spec.appName} spec: containers: - name: ${schema.spec.appName}-container image: ${schema.spec.image} - name: service definition: apiVersion: v1 kind: Service metadata: name: ${schema.spec.appName}-service spec: selector: app: ${schema.spec.appName} ports: - port: 80 targetPort: 80   In this example, the ResourceGroup defines a simple web application with a Deployment and a Service. The appName, image, and replicas are parameters that can be set when instantiating this ResourceGroup.  ","version":"latest","tagName":"h2"},{"title":"ResourceGroup Processing​","type":1,"pageTitle":"1. ResourceGroups","url":"/docs/docs/concepts/resource-groups#resourcegroup-processing","content":" When a ResourceGroup is submitted to the Kubernetes API server, the KRO controller processes it as follows:  Formal Verification: The controller performs a comprehensive analysis of the ResourceGroup definition. This includes: Syntax checking: Ensuring all fields are correctly formatted.Type checking: Validating that parameter types match their definitions.Semantic validation: Verifying that resource relationships and dependencies are logically sound.Dry-run validation: Simulating the creation of resources to detect potential issues. CRD Generation: The controller automatically generates a new Custom Resource Definition (CRD) based on the ResourceGroup's specification. This CRD represents the type for instances of this ResourceGroup. CRD Registration: It registers the newly generated CRD with the Kubernetes API server, making it available for use in the cluster. Micro-Controller Deployment: KRO deploys a dedicated micro-controller for this ResourceGroup. This micro-controller will listen for &quot;instance&quot; events - instances of the CRD created in step 2. It will be responsible for managing the lifecycle of resources defined in the ResourceGroup for each instance. Status Update: The controller updates the status of the ResourceGroup to reflect that the corresponding CRD has been created and registered.  For example, given our simple-web-app ResourceGroup, the controller would create and register a CRD named SimpleWebApps (plural form of the ResourceGroup name). This CRD defines the structure for creating instances of the web application with customizable parameters. The deployed micro-controller would then manage all SimpleWebApps instances, creating and managing the associated Deployments and Services as defined in the ResourceGroup.  The KRO controller continues to monitor the ResourceGroup for any changes, updating the corresponding CRD and micro-controller as necessary.  ","version":"latest","tagName":"h2"},{"title":"ResourceGroup Instance Example​","type":1,"pageTitle":"1. ResourceGroups","url":"/docs/docs/concepts/resource-groups#resourcegroup-instance-example","content":" After the ResourceGroup is processed, users can create instances of it. Here's an example of how an instance for the SimpleWebApp might look:  my-web-app-instance.yaml apiVersion: kro.run/v1alpha1 kind: SimpleWebApp metadata: name: my-web-app spec: appName: awesome-app image: nginx:latest replicas: 3   In the next section, we'll explore the parameters and resources sections of a ResourceGroup in more detail. ","version":"latest","tagName":"h2"},{"title":"2. Simple Schema","type":0,"sectionRef":"#","url":"/docs/docs/concepts/simple-schema","content":"","keywords":"","version":"latest"},{"title":"Simple Schema Features Explained​","type":1,"pageTitle":"2. Simple Schema","url":"/docs/docs/concepts/simple-schema#simple-schema-features-explained","content":" ","version":"latest","tagName":"h2"},{"title":"1. Spec Field Definition​","type":1,"pageTitle":"2. Simple Schema","url":"/docs/docs/concepts/simple-schema#1-spec-field-definition","content":" Basic Types​  string: Basic string typeinteger: Whole numberboolean: True/False value  for example to define a field that is a string, you can define it as follows:  name: string age: integer   Structure types​  Structure types or object types are defined by specifying the fields within the object. The fields can be of basic types or other structure types.  for example to define a structure type for a person with name and age fields, you can define it as follows:  person: name: string age: integer   Map Types​  Arrays: Denoted by [], e.g., '[]string'Maps: Denoted by map[keyType]valueType, e.g., 'map[string]string' and'map[string]Person'  ","version":"latest","tagName":"h3"},{"title":"2. Validation and Documentation Markers​","type":1,"pageTitle":"2. Simple Schema","url":"/docs/docs/concepts/simple-schema#2-validation-and-documentation-markers","content":" In addition to the type, fields can also have markers for validation, documentation and other purposes that are OpenAPISchema compatible.  For example to define a field that is required, has a default value and a description, you can define it as follows:  person: name: string | required=true default=&quot;Kylian Mbappé&quot; description=&quot;Name of the person&quot;   Currently supported markers include:  required=true: Field must be provideddefault=value: Default value if not provideddescription=&quot;...&quot;: Provides documentation for the fieldenum=&quot;value1,value2,...&quot;: Restricts to a set of values NOT IMPLEMENTEDminimum=value and maximum=value: For numeric constraints NOT IMPLEMENTED  ","version":"latest","tagName":"h3"},{"title":"3. Custom Types Definition​","type":1,"pageTitle":"2. Simple Schema","url":"/docs/docs/concepts/simple-schema#3-custom-types-definition","content":" Custom types are defined in the customTypes section, allowing for reusable complex structures. They can be referenced by name in the spec or status fields.  Example:  customTypes: ConfigType: logLevel: string | enum=&quot;debug,info,warn,error&quot; default=&quot;info&quot; maxConnections: integer | minimum=1 maximum=1000 spec: config: ConfigType | required=true   ","version":"latest","tagName":"h3"},{"title":"4. Status Field Definition​","type":1,"pageTitle":"2. Simple Schema","url":"/docs/docs/concepts/simple-schema#4-status-field-definition","content":" Status fields are defined similarly to spec fields and can include validation and documentation markers. However on top of that, status fields can also include value markers:  Value Marker NOT IMPLEMENTED​  value=&quot;${resource.status.field}&quot;: Specifies that this field's value should be dynamically obtained from another resource. The value is a CEL expression that is validated at ResourceGroup processing time and evaluated at runtime.  Note that the value marker is a KRO extension to the OpenAPISchema and is not part of the official OpenAPISchema specification. ::: Example: status: url: string | value=&quot;${service.status.loadBalancer.ingress[0].hostname}&quot; Default status fields​ KRO automatically injects two common fields into the status of all instances generated from ResourceGroups: conditions and state. These fields provide essential information about the current status of the instance and its associated resources. conditions and state are reserved words in the status section. If a user defines these fields in their ResourceGroup's status schema, KRO will override them with its own values. ::: 1. Conditions​ The conditions field is an array of condition objects, each representing a specific aspect of the instance's state. KRO automatically manages this field. status: conditions: &quot;[]condition&quot; customTypes: condition: type: string status: string | enum=&quot;True,False,Unknown&quot; lastTransitionTime: string reason: string message: string Common condition types include: Ready: Indicates whether the instance is fully reconciled and operational.Progressing: Shows if the instance is in the process of reaching the desired state.Degraded: Signals that the instance is operational but not functioning optimally.Error: Indicates that an error has occurred during reconciliation. 2. State​ The state field provides a high-level summary of the instance's current status. status: state: string | enum=&quot;Ready,Progressing,Degraded,Error,Terminating,Unknown&quot; These default status fields are automatically added to every instance's status, providing a consistent way to check the health and state of resources across different ResourceGroups. ","version":"latest","tagName":"h3"},{"title":"DeploymentService","type":0,"sectionRef":"#","url":"/docs/examples/deploymentservice","content":"DeploymentService deploymentservice-rg.yaml apiVersion: kro.run/v1alpha1 kind: ResourceGroup metadata: name: deploymentservice spec: apiVersion: v1alpha1 kind: DeploymentService definition: spec: name: string resources: - name: deployment definition: apiVersion: apps/v1 kind: Deployment metadata: name: ${schema.spec.name} spec: replicas: 1 selector: matchLabels: app: deployment template: metadata: labels: app: deployment spec: containers: - name: ${schema.spec.name}-deployment image: nginx ports: - containerPort: 80 - name: service definition: apiVersion: v1 kind: Service metadata: name: ${schema.spec.name} spec: selector: app: deployment ports: - protocol: TCP port: 80 targetPort: 80 ","keywords":"","version":"latest"},{"title":"What is KRO?","type":0,"sectionRef":"#","url":"/docs/docs/overview","content":"","keywords":"","version":"latest"},{"title":"Developer interface​","type":1,"pageTitle":"What is KRO?","url":"/docs/docs/overview#developer-interface","content":" When the end user applies a YAML spec to the cluster using the Custom API, the API creates a set of resources within the cluster. These resources can include both native Kubernetes resources and any Custom Resource Definitions (CRDs) installed in the cluster. Some of these resources may create additional resources outside of your cluster.  As depicted in the following diagram, the Developers call the Custom API, which creates resources such as the Deployment, Ingress, ServiceAccount,Prometheus Monitor, IAM Role, IAM Policy, and Amazon S3 Bucket. This allows the Developers to easily manage and deploy their applications in a standardized and streamlined manner.  Fugure 1: End user interface - Custom API  ","version":"latest","tagName":"h3"},{"title":"ResourceGroup​","type":1,"pageTitle":"What is KRO?","url":"/docs/docs/overview#resourcegroup","content":" When you install Kro in your cluster, it installs a Custom Resource Definition (CRD) called ResourceGroup (RG). The Platform, Security, and Compliance teams, can collaborate to create custom APIs by defining Custom Resources for the ResourceGroup CRD.  In the depicted example, the Platform Team has created an Application Stack RG that encapsulates the necessary resources, along with any additional logic, abstractions, and security best practices. This empowers the Developers to interact with an API when managing their applications. The Developers no longer need to directly manage the underlying infrastructure complexities, as the custom API handles the deployment and configuration of the required resources.  Fugure 2: ResourceGroup (RG) - Platform Team Interface  ","version":"latest","tagName":"h3"},{"title":"ResourceGroup Instance​","type":1,"pageTitle":"What is KRO?","url":"/docs/docs/overview#resourcegroup-instance","content":" Developer teams can create multiple instances of the Application Stack, each tailored to their specific requirements. As shown, Dev Team A and Dev Team B have both instantiated their own Application Stacks. While the underlying resources are similar, Dev Team A has chosen to expose their service externally, leveraging the Ingress option, while Dev Team B has opted to keep their service internal to the cluster. This flexibility allows each development team to customize their application stack based on their specific requirements.  Fugure 3: ResourceGroup Instance (RGI)  Why KRO?  ","version":"latest","tagName":"h3"},{"title":"Manage any group of resources as one unit​","type":1,"pageTitle":"What is KRO?","url":"/docs/docs/overview#manage-any-group-of-resources-as-one-unit","content":" Using KRO, the Platform Team can enable Developer teams to quickly deploy and manage applications and their dependencies as one unit, handling the entire lifecycle from deployment to maintenance. The new APIs integrate seamlessly with developers' existing CD tools, preserving familiar processes and interfaces to simplify adoption.  ","version":"latest","tagName":"h3"},{"title":"Collaborate​","type":1,"pageTitle":"What is KRO?","url":"/docs/docs/overview#collaborate","content":" Transform Kubernetes into your unified platform configuration framework using KRO. Platform, Compliance, and Security teams work together to develop APIs that standardize and streamline configurations, making it easier for Developer teams to adopt secure, compliant practices. This collaboration lets you build your organizational standards directly into the APIs, ensuring every application deployment aligns with security and compliance requirements without adding complexity for developers.  ","version":"latest","tagName":"h3"},{"title":"Standardize​","type":1,"pageTitle":"What is KRO?","url":"/docs/docs/overview#standardize","content":" By creating unified APIs, you can define and enforce best practices across all environments, ensuring every application meets organizational requirements and achieving consistency across deployment environments.  Community  We welcome questions, suggestions, and contributions from the community! To get involved, check out ourcontributing guide. For bugs or feature requests, feel free tosubmit an issue. You’re also invited to join ourcommunity meeting. ","version":"latest","tagName":"h3"},{"title":"Installing KRO","type":0,"sectionRef":"#","url":"/docs/docs/getting-started/Installation","content":"","keywords":"","version":"latest"},{"title":"Prerequisites​","type":1,"pageTitle":"Installing KRO","url":"/docs/docs/getting-started/Installation#prerequisites","content":" Before you begin, ensure you have the following:  Helm 3.x installedkubectl installed and configured to interact with your Kubernetes cluster  ","version":"latest","tagName":"h2"},{"title":"Installation Steps​","type":1,"pageTitle":"Installing KRO","url":"/docs/docs/getting-started/Installation#installation-steps","content":" Alpha Stage KRO is currently in alpha stage. While the images arepublicly available, please note that the software is still under active development and APIs may change.  ","version":"latest","tagName":"h2"},{"title":"Install KRO using Helm​","type":1,"pageTitle":"Installing KRO","url":"/docs/docs/getting-started/Installation#install-kro-using-helm","content":" Once authenticated, install KRO using the Helm chart:  # Fetch the latest release version from GitHub export KRO_VERSION=$(curl -s \\ https://api.github.com/repos/awslabs/kro/releases/latest | \\ grep '&quot;tag_name&quot;:' | \\ sed -E 's/.*&quot;([^&quot;]+)&quot;.*/\\1/' \\ ) # Install KRO using Helm helm install kro oci://public.ecr.aws/kro/kro \\ --namespace kro \\ --create-namespace \\ --version=${KRO_VERSION}   ","version":"latest","tagName":"h3"},{"title":"Verifying the Installation​","type":1,"pageTitle":"Installing KRO","url":"/docs/docs/getting-started/Installation#verifying-the-installation","content":" After running the installation command, verify that Kro has been installed correctly:  Check the Helm release: helm list You should see the &quot;kro&quot; release listed. Check the KRO pods: kubectl get pods -n kro You should see kro-related pods running.  ","version":"latest","tagName":"h2"},{"title":"Upgrading KRO​","type":1,"pageTitle":"Installing KRO","url":"/docs/docs/getting-started/Installation#upgrading-kro","content":" To upgrade to a newer version of KRO, use the Helm upgrade command:  # Replace `&lt;new-version&gt;` with the version you want to upgrade to. export KRO_VERSION=&lt;new-version&gt; # Upgrade the controller helm upgrade kro oci://public.ecr.aws/kro/kro \\ --namespace kro \\ --version=${KRO_VERSION}   CRD Updates Helm does not support updating CRDs, so you may need to manually update or remove kro related CRDs. For more information, refer to the Helm documentation.  ","version":"latest","tagName":"h2"},{"title":"Uninstalling KRO​","type":1,"pageTitle":"Installing KRO","url":"/docs/docs/getting-started/Installation#uninstalling-kro","content":" To uninstall KRO, use the following command:  helm uninstall kro -n kro   Keep in mind that this command will remove all KRO resources from your cluster, except for the ResourceGroup CRD and any other custom resources you may have created. ","version":"latest","tagName":"h2"},{"title":"Empty ResourceGroup","type":0,"sectionRef":"#","url":"/docs/examples/empty","content":"Empty ResourceGroup no-resources-rg.yaml apiVersion: kro.run/v1alpha1 kind: ResourceGroup metadata: name: kro.run/v1alpha1 spec: apiVersion: v1alpha1 kind: Noop definition: spec: name: string | required=true resources: [] ","keywords":"","version":"latest"},{"title":"DeploymentDBInstance","type":0,"sectionRef":"#","url":"/docs/examples/deploymentdbinstance","content":"DeploymentDBInstance deploymentdbinstance-rg.yaml apiVersion: kro.run/v1alpha1 kind: ResourceGroup metadata: name: deploymentandawspostgres spec: apiVersion: v1alpha1 kind: DeploymentAndAWSPostgres # CRD Definition definition: spec: applicationName: string image: string location: string # Resources resources: - name: dbinstance definition: apiVersion: rds.saervices.k8s.aws/v1alpha1 kind: DBInstance metadata: name: ${schema.spec.applicationName}-dbinstance spec: # need to specify the required fields (e.g masterUsername, masterPassword) engine: postgres dbInstanceIdentifier: ${schema.spec.applicationName}-dbinstance allocatedStorage: 20 dbInstanceClass: db.t3.micro - name: pod definition: apiVersion: v1 kind: Pod metadata: name: ${schema.spec.applicationName}-pod spec: containers: - name: container1 image: ${schema.spec.image} env: - name: POSTGRESS_ENDPOINT value: ${dbinstance.status.endpoint.address} ","keywords":"","version":"latest"},{"title":"7. Validation","type":0,"sectionRef":"#","url":"/docs/docs/concepts/validation","content":"7. Validation Validation","keywords":"","version":"latest"},{"title":"API Reference","type":0,"sectionRef":"#","url":"/docs/api/out","content":"","keywords":"","version":"latest"},{"title":"Packages​","type":1,"pageTitle":"API Reference","url":"/docs/api/out#packages","content":" kro.run/v1alpha1  ","version":"latest","tagName":"h2"},{"title":"kro.run/v1alpha1​","type":1,"pageTitle":"API Reference","url":"/docs/api/out#krorunv1alpha1","content":" Package v1alpha1 contains API Schema definitions for the x v1alpha1 API group  ","version":"latest","tagName":"h2"},{"title":"Resource Types​","type":1,"pageTitle":"API Reference","url":"/docs/api/out#resource-types","content":" ResourceGroupResourceGroupList  Condition​  Condition is the common struct used by all CRDs managed by ACK service controllers to indicate terminal states of the CR and its backend AWS service API resource  Appears in:  ResourceGroupStatus  Field\tDescription\tDefault\tValidationtype ConditionType\tType is the type of the Condition status ConditionStatus\tStatus of the condition, one of True, False, Unknown. lastTransitionTime Time\tLast time the condition transitioned from one status to another. reason string\tThe reason for the condition's last transition. message string\tA human readable message indicating details about the transition. observedGeneration integer\tobservedGeneration represents the .metadata.generation that the condition was set based upon. For instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date with respect to the current state of the instance. Minimum: 0   ConditionType​  Underlying type: string  Appears in:  Condition  Definition​  Appears in:  ResourceGroupSpec  Field\tDescription\tDefault\tValidationspec RawExtension status RawExtension types RawExtension validation string array   Resource​  Appears in:  ResourceGroupSpec  Field\tDescription\tDefault\tValidationname string Required: definition RawExtension Required:   ResourceGroup​  ResourceGroup is the Schema for the resourcegroups API  Appears in:  ResourceGroupList  Field\tDescription\tDefault\tValidationapiVersion string\tkro.run/v1alpha1 kind string\tResourceGroup kind string\tKind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds apiVersion string\tAPIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources metadata ObjectMeta\tRefer to Kubernetes API documentation for fields of metadata. spec ResourceGroupSpec status ResourceGroupStatus   ResourceGroupList​  ResourceGroupList contains a list of ResourceGroup  Field\tDescription\tDefault\tValidationapiVersion string\tkro.run/v1alpha1 kind string\tResourceGroupList kind string\tKind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds apiVersion string\tAPIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources metadata ListMeta\tRefer to Kubernetes API documentation for fields of metadata. items ResourceGroup array   ResourceGroupSpec​  ResourceGroupSpec defines the desired state of ResourceGroup  Appears in:  ResourceGroup  Field\tDescription\tDefault\tValidationkind string Required: apiVersion string Required: definition Definition Required: resources Resource array Optional:   ResourceGroupState​  Underlying type: string  Appears in:  ResourceGroupStatus  ResourceGroupStatus​  ResourceGroupStatus defines the observed state of ResourceGroup  Appears in:  ResourceGroup  Field\tDescription\tDefault\tValidationstate ResourceGroupState\tState is the state of the resourcegroup topologicalOrder string array\tTopologicalOrder is the topological order of the resourcegroup graph conditions Condition array\tConditions represent the latest available observations of an object's state  ","version":"latest","tagName":"h3"},{"title":"4. Collections","type":0,"sectionRef":"#","url":"/docs/docs/concepts/collections","content":"","keywords":"","version":"latest"},{"title":"What are Collections?​","type":1,"pageTitle":"4. Collections","url":"/docs/docs/concepts/collections#what-are-collections","content":" A collection is a special field in a ResourceGroup that defines a template for creating multiple similar resources. Key features of collections include:  Dynamic creation of resources based on user inputConsistent structure across multiple resource instancesSimplified management of groups of related resources  ","version":"latest","tagName":"h2"},{"title":"Defining a Collection​","type":1,"pageTitle":"4. Collections","url":"/docs/docs/concepts/collections#defining-a-collection","content":" Here's an example of how to define a collection in a ResourceGroup:  apiVersion: kro.run/v1alpha1 kind: ResourceGroup metadata: name: replica-set spec: kind: ReplicaSet apiVersion: v1alpha1 parameters: spec: clusterName: string podCount: integer | minimum=1 maximum=5 resources: - name: nodesCollection collection: index: ${range(0, schema.spec.podCount)} definition: apiVersion: v1 kind: Pod metadata: name: ${clusterName}-node-${index} spec: containers: - name: db image: nginx:latest   In this example, nodes is a collection that will create multiple Pod resources based on the podCount parameter.  ","version":"latest","tagName":"h2"},{"title":"Key Concepts​","type":1,"pageTitle":"4. Collections","url":"/docs/docs/concepts/collections#key-concepts","content":" index: Specifies the range of values for the collection, allowing for dynamic creation of multiple resources. definition: Defines the structure of each resource instance in the collection. The ${index} variable ensures uniqueness of each resource.  ","version":"latest","tagName":"h2"},{"title":"Using Collections in Instances​","type":1,"pageTitle":"4. Collections","url":"/docs/docs/concepts/collections#using-collections-in-instances","content":" When creating an instance, users can specify the count for the collection:  apiVersion: kro.run/v1alpha1 kind: ReplicaSet metadata: name: my-db-cluster spec: clusterName: production-db podCount: 3   This instance will result in the creation of three Postgres Pods namedproduction-db-node-0, production-db-node-1, and production-db-node-2.  ","version":"latest","tagName":"h2"},{"title":"Deployment Strategy​","type":1,"pageTitle":"4. Collections","url":"/docs/docs/concepts/collections#deployment-strategy","content":" While defining collections is straightforward, it's essential to consider the deployment strategy for managing multiple resources. KRO provides flexibility in managing collections, allowing users to define how resources are created, updated, and deleted based on the desired state.  KRO provide two strategies for managing collections:  RollingUpdate: Creates, updates and deletes resources in an incremental manner, ensuring that only one resource is updated at a time.ParallelUpdate: Creates, updates and deletes resources in parallel, allowing for faster deployment of multiple resources.  For examples you can add the following to the spec section of theResourceGroup:  spec: kind: ReplicaSet apiVersion: v1alpha1 parameters: spec: clusterName: string podCount: integer | minimum=1 maximum=5 resources: - name: nodes strategy: RollingUpdate collection: index: ${range(0, schema.spec.podCount)} definition: apiVersion: v1 kind: Pod metadata: name: ${clusterName}-node-${index} spec: containers: - name: db image: nginx:latest  ","version":"latest","tagName":"h2"},{"title":"3. Instances","type":0,"sectionRef":"#","url":"/docs/docs/concepts/instances","content":"","keywords":"","version":"latest"},{"title":"What is an Instance?​","type":1,"pageTitle":"3. Instances","url":"/docs/docs/concepts/instances#what-is-an-instance","content":" An Instance is a Kubernetes custom resource that:  References a specific ResourceGroupProvides values for the parameters defined in the ResourceGroupRepresents the desired state of a set of Kubernetes resources  ","version":"latest","tagName":"h2"},{"title":"Anatomy of an Instance​","type":1,"pageTitle":"3. Instances","url":"/docs/docs/concepts/instances#anatomy-of-an-instance","content":" Here's an example of an Instance for a WebApplication ResourceGroup:  apiVersion: kro.run/v1alpha1 kind: WebApplication metadata: name: my-web-app spec: name: awesome-app replicas: 3 image: nginx:latest ports: - port: 80 targetPort: 8080 env: DB_HOST: mydb.example.com LOG_LEVEL: debug   The spec fields of an Instance correspond to the parameters defined in the ResourceGroup. ::: The reconciliation loop​ KRO manages Instances through a continuous reconciliation process: Desired state detection: KRO observes the Instance, which represents the desired state of resources.Current state assessment: KRO talks to the api-server and checks the current state of resources in the cluster related to the Instance.Difference identification: Any differences between the desired state (Instance) and the current state are identified.State Reconciliation: KRO takes necessary actions to align the current state with the desired state. This may involve creating, updating, or deleting resources as needed.Status Updates: The Instance's status is updated to reflect the current state of reconciliation and any issues encountered.Continuous Loop: This process repeats regularly, ensuring the cluster state always converges towards the desired state defined in the Instance. Advantages of declarative management [need better title]​ Declarative Management: Users define what they want, not how to get there.Self-healing: The system continuously works to maintain the desired state.Idempotency: The same Instance always results in the same end state, regardless of the current state.Abstraction: Complex resource relationships are managed behind the scenes.Consistency: All resources for an application are managed as a unit.Auditability: The Instance serves as a single source of truth for the application's desired state. Best Practices Treat instances as declarative definitions of your application's desired state. Use version control for your Instances to track changes over time.Leverage labels and annotations in Instances for organization and filtering.Regularly review Instances to ensure they reflect current requirements.Use KRO's dry-run feature to preview reconciliation actions before applying changes to Instances.Monitor Instance statuses to understand the current state of your applications.  ","version":"latest","tagName":"h2"},{"title":"Common Status Fields​","type":1,"pageTitle":"3. Instances","url":"/docs/docs/concepts/instances#common-status-fields","content":" KRO automatically injects two common fields into the status of all instances:Conditions and State. These fields provide crucial information about the current status of the instance and its associated resources.  ","version":"latest","tagName":"h2"},{"title":"1. Conditions​","type":1,"pageTitle":"3. Instances","url":"/docs/docs/concepts/instances#1-conditions","content":" Conditions are a standard Kubernetes concept that KRO leverages to provide detailed status information. Each condition represents a specific aspect of the instance's state. Common conditions include:  Ready: Indicates whether the instance is fully reconciled and operational.Progressing: Shows if the instance is in the process of reaching the desired state.Degraded: Signals that the instance is operational but not functioning optimally.Error: Indicates that an error has occurred during reconciliation.  Each condition typically includes the following properties:  Type: The name of the condition (e.g., &quot;Ready&quot;).Status: Either &quot;True&quot;, &quot;False&quot;, or &quot;Unknown&quot;.LastTransitionTime: When the condition last changed.Reason: A brief, machine-readable explanation for the condition's state.Message: A human-readable description of the condition.  Example:  status: conditions: - type: Ready status: &quot;True&quot; lastTransitionTime: &quot;2024-07-23T01:01:59Z&quot; reason: ResourcesAvailable message: &quot;All resources are available and configured correctly&quot;   ","version":"latest","tagName":"h3"},{"title":"2. State​","type":1,"pageTitle":"3. Instances","url":"/docs/docs/concepts/instances#2-state","content":" The State field provides a high-level summary of the instance's current status. It is typically one of the following values:  Pending: The instance is being processed, but resources are not yet fully created or configured.Running: All resources are created and the instance is operational.Failed: An error occurred and the instance could not be fully reconciled.Terminating: The instance is in the process of being deleted.Degraded: The instance is operational but not functioning optimally.Unknown: The instance's status cannot be determined.  Example:  status: state: Running   These common status fields provide users with a consistent and informative way to check the health and state of their instances across different ResourceGroups. They are essential for monitoring, troubleshooting, and automating operations based on the status of KRO-managed resources. ","version":"latest","tagName":"h3"},{"title":"EKSCluster","type":0,"sectionRef":"#","url":"/docs/examples/ekscluster","content":"EKSCluster ekscluster-rg.yaml apiVersion: kro.run/v1alpha1 kind: ResourceGroup metadata: name: kro.run/v1alpha1 spec: # CRD Definition apiVersion: v1alpha1 kind: EKSCluster definition: spec: name: string version: string numNodes: integer # resources resources: - name: clusterVPC definition: apiVersion: ec2.services.k8s.aws/v1alpha1 kind: VPC metadata: name: cluster-vpc-${schema.spec.name} spec: cidrBlocks: - 192.168.0.0/16 enableDNSHostnames: false enableDNSSupport: true - name: subnetAZA definition: apiVersion: ec2.services.k8s.aws/v1alpha1 kind: Subnet metadata: name: cluster-subnet-a-${schema.spec.name} spec: availabilityZone: us-west-2a cidrBlock: 192.168.0.0/18 vpcID: ${clusterVPC.status.vpcID} - name: securityGroup definition: apiVersion: ec2.services.k8s.aws/v1alpha1 kind: SecurityGroup metadata: name: cluster-security-group-${schema.spec.name} spec: vpcID: ${clusterVPC.status.vpcID} name: my-eks-cluster-sg-${schema.spec.name} description: something something - name: subnetAZB definition: apiVersion: ec2.services.k8s.aws/v1alpha1 kind: Subnet metadata: name: cluster-subnet-b-${schema.spec.name} spec: availabilityZone: us-west-2b cidrBlock: 192.168.64.0/18 vpcID: ${clusterVPC.status.vpcID} - name: clusterRole definition: apiVersion: iam.services.k8s.aws/v1alpha1 kind: Role metadata: name: cluster-role-${schema.spec.name} spec: name: cluster-role-${schema.spec.name} policies: - arn:aws:iam::aws:policy/AmazonEKSClusterPolicy assumeRolePolicyDocument: | { &quot;Version&quot;: &quot;2012-10-17&quot;, &quot;Statement&quot;: [ { &quot;Effect&quot;: &quot;Allow&quot;, &quot;Principal&quot;: { &quot;Service&quot;: &quot;eks.amazonaws.com&quot; }, &quot;Action&quot;: &quot;sts:AssumeRole&quot; } ] } - name: nodeRole definition: apiVersion: iam.services.k8s.aws/v1alpha1 kind: Role metadata: name: cluster-node-role-${schema.spec.name} spec: name: cluster-node-role-${schema.spec.name} policies: - arn:aws:iam::aws:policy/AmazonEKSWorkerNodePolicy - arn:aws:iam::aws:policy/AmazonEC2ContainerRegistryReadOnly - arn:aws:iam::aws:policy/AmazonEKS_CNI_Policy assumeRolePolicyDocument: | { &quot;Version&quot;: &quot;2012-10-17&quot;, &quot;Statement&quot;: [ { &quot;Effect&quot;: &quot;Allow&quot;, &quot;Principal&quot;: { &quot;Service&quot;: &quot;ec2.amazonaws.com&quot; }, &quot;Action&quot;: &quot;sts:AssumeRole&quot; } ] } - name: cluster definition: apiVersion: eks.services.k8s.aws/v1alpha1 kind: Cluster metadata: name: cluster-${schema.spec.name} spec: name: cluster-${schema.spec.name} roleARN: ${clusterRole.status.ackResourceMetadata.arn} version: ${schema.spec.version} resourcesVPCConfig: subnetIDs: - ${subnetAZA.status.subnetID} - ${subnetAZB.status.subnetID} - name: nodegroup definition: apiVersion: eks.services.k8s.aws/v1alpha1 kind: Nodegroup metadata: name: nodegroup-${schema.spec.name} spec: name: nodegroup-${schema.spec.name} clusterName: cluster-${schema.spec.name} subnets: - ${subnetAZA.status.subnetID} - ${subnetAZB.status.subnetID} nodeRole: ${nodeRole.status.ackResourceMetadata.arn} updateConfig: maxUnavailable: 1 scalingConfig: minSize: ${schema.spec.numNodes} maxSize: ${schema.spec.numNodes} desiredSize: ${schema.spec.numNodes} ","keywords":"","version":"latest"},{"title":"Deploy Your First ResourceGroup","type":0,"sectionRef":"#","url":"/docs/docs/getting-started/deploy-a-resource-group","content":"","keywords":"","version":"latest"},{"title":"What is a ResourceGroup?​","type":1,"pageTitle":"Deploy Your First ResourceGroup","url":"/docs/docs/getting-started/deploy-a-resource-group#what-is-a-resourcegroup","content":" A ResourceGroup lets you create new Kubernetes APIs that deploy multiple resources together as a single, reusable unit. For example, instead of repeatedly creating Deployments, Services and Ingress resources separately, you can create a ResourceGroup that packages them into one reusable API. Users can then deploy resources as a single unit, ensuring they're always created together with the right configuration.  Under the hood, when you create a ResourceGroup, KRO:  Treats your resources as a Directed Acyclic Graph (DAG) to understand their dependenciesValidates resource definitions and detects the correct deployment orderCreates a new API (CRD) in your clusterConfigures itself to watch and serve instances of this API  info KRO is a Kubernetes-native tool that only speaks Kubernetes! No external services or databases needed - just pure Kubernetes APIs. Whether it's native resources or custom ones, KRO understands and works with them all.  ","version":"latest","tagName":"h2"},{"title":"Prerequisites​","type":1,"pageTitle":"Deploy Your First ResourceGroup","url":"/docs/docs/getting-started/deploy-a-resource-group#prerequisites","content":" Before you begin, make sure you have the following:  KRO installed and running in your Kubernetes cluster.kubectl installed and configured to interact with your Kubernetes cluster.  ","version":"latest","tagName":"h2"},{"title":"Create your Application ResourceGroup​","type":1,"pageTitle":"Deploy Your First ResourceGroup","url":"/docs/docs/getting-started/deploy-a-resource-group#create-your-application-resourcegroup","content":" Let's create a Resource Group that combines a Deployment, a Service andIngress. Save this as resourcegroup.yaml:  resourcegroup.yaml apiVersion: kro.run/v1alpha1 kind: ResourceGroup metadata: name: my-application spec: # This becomes your CRD schema - defines what users can provide in their instances schema: apiVersion: v1alpha1 kind: Application spec: # Spec fields that users can provide. name: string image: string | default=&quot;nginx&quot; ingress: enabled: boolean | default=false status: # Fields the controller will inject into instances status. deploymentConditions: ${deployment.status.conditions} availableReplicas: ${deployment.status.availableReplicas} # Define the resources this API will manage. resources: - name: deployment template: apiVersion: apps/v1 kind: Deployment metadata: name: ${schema.spec.name} # Use the name provided by user spec: replicas: 3 selector: matchLabels: app: ${schema.spec.name} template: metadata: labels: app: ${schema.spec.name} spec: containers: - name: ${schema.spec.name} image: ${schema.spec.image} # Use the image provided by user ports: - containerPort: 80 - name: service template: apiVersion: v1 kind: Service metadata: name: ${schema.spec.name}-service spec: selector: ${deployment.spec.selector.matchLabels} # Use the deployment selector ports: - protocol: TCP port: 80 targetPort: 80 - name: ingress includeWhen: - ${schema.spec.ingress.enabled} # Only include if the user wants to create an Ingress template: apiVersion: networking.k8s.io/v1 kind: Ingress metadata: name: ${schema.spec.name}-ingress annotations: kubernetes.io/ingress.class: alb alb.ingress.kubernetes.io/scheme: internet-facing alb.ingress.kubernetes.io/target-type: ip alb.ingress.kubernetes.io/healthcheck-path: /health alb.ingress.kubernetes.io/listen-ports: '[{&quot;HTTP&quot;: 80}]' alb.ingress.kubernetes.io/target-group-attributes: stickiness.enabled=true,stickiness.lb_cookie.duration_seconds=60 spec: rules: - http: paths: - path: &quot;/&quot; pathType: Prefix backend: service: name: ${service.metadata.name} # Use the service name port: number: 80   ","version":"latest","tagName":"h2"},{"title":"Deploy the ResourceGroup​","type":1,"pageTitle":"Deploy Your First ResourceGroup","url":"/docs/docs/getting-started/deploy-a-resource-group#deploy-the-resourcegroup","content":" Create a ResourceGroup manifest file: Create a new file with theResourceGroup definition. You can use the example above. Apply the ResourceGroup: Use the kubectl command to deploy the ResourceGroup to your Kubernetes cluster: kubectl apply -f resourcegroup.yaml Inpsect the ResourceGroup: Check the status of the resources created by the ResourceGroup using the kubectl command: kubectl get rg my-application -owide You should see the ResourceGroup in the Active state, along with relevant information to help you understand your application: NAME APIVERSION KIND STATE TOPOLOGICALORDER AGE my-application v1alpha1 Application Active [&quot;deployment&quot;,&quot;service&quot;,&quot;ingress&quot;] 49   ","version":"latest","tagName":"h3"},{"title":"Create your Application Instance​","type":1,"pageTitle":"Deploy Your First ResourceGroup","url":"/docs/docs/getting-started/deploy-a-resource-group#create-your-application-instance","content":" Now that your ResourceGroup is created, KRO has generated a new API (Application) that orchestrates creation of the a Deployment, a Service, and an Ingress. Let's use it!  Create an Application instance: Create a new file named instance.yamlwith the following content: instance.yaml apiVersion: kro.run/v1alpha1 kind: Application metadata: name: my-application-instance spec: name: my-awesome-app ingress: enabled: true Apply the Application instance: Use the kubectl command to deploy the Application instance to your Kubernetes cluster: kubectl apply -f instance.yaml Inspect the Application instance: Check the status of the resources kubectl get applications After a few seconds, you should see the Application instance in the Activestate: NAME STATE SYNCED AGE my-application-instance ACTIVE True 10s Inspect the resources: Check the resources created by the Application instance: kubectl get deployments,services,ingresses You should see the Deployment, Service, and Ingress created by the Application instance. NAME READY UP-TO-DATE AVAILABLE AGE deployment.apps/my-awesome-app 3/3 3 3 69s NAME TYPE CLUSTER-IP EXTERNAL-IP PORT(S) AGE service/my-awesome-app-service ClusterIP 10.100.167.72 &lt;none&gt; 80/TCP 65s NAME CLASS HOSTS ADDRESS PORTS AGE ingress.networking.k8s.io/my-awesome-app-ingress &lt;none&gt; * 80 62s   ","version":"latest","tagName":"h3"},{"title":"Delete the Application instance​","type":1,"pageTitle":"Deploy Your First ResourceGroup","url":"/docs/docs/getting-started/deploy-a-resource-group#delete-the-application-instance","content":" KRO can also help you clean up resources when you're done with them.  Delete the Application instance: Clean up the resources by deleting the Application instance: kubectl delete application my-application-instance Now, the resources created by the Application instance will be deleted. ","version":"latest","tagName":"h3"}],"options":{"id":"default"}}