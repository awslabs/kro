{"searchDocs":[{"title":"6. Imports","type":0,"sectionRef":"#","url":"/docs/docs/concepts/imports","content":"6. Imports Imports ...","keywords":"","version":"latest"},{"title":"5. Conditionals","type":0,"sectionRef":"#","url":"/docs/docs/concepts/conditionals","content":"5. Conditionals","keywords":"","version":"latest"},{"title":"7. Validation","type":0,"sectionRef":"#","url":"/docs/docs/concepts/validation","content":"7. Validation Validation","keywords":"","version":"latest"},{"title":"2. Simple Schema","type":0,"sectionRef":"#","url":"/docs/docs/concepts/simple-schema","content":"","keywords":"","version":"latest"},{"title":"Simple Schema Features Explained​","type":1,"pageTitle":"2. Simple Schema","url":"/docs/docs/concepts/simple-schema#simple-schema-features-explained","content":" ","version":"latest","tagName":"h2"},{"title":"1. Spec Field Definition​","type":1,"pageTitle":"2. Simple Schema","url":"/docs/docs/concepts/simple-schema#1-spec-field-definition","content":" Basic Types​  string: Basic string typeinteger: Whole numberboolean: True/False value  for example to define a field that is a string, you can define it as follows:  name: string age: integer   Structure types​  Structure types or object types are defined by specifying the fields within the object. The fields can be of basic types or other structure types.  for example to define a structure type for a person with name and age fields, you can define it as follows:  person: name: string age: integer   Map Types​  Arrays: Denoted by [], e.g., '[]string'Maps: Denoted by map[keyType]valueType, e.g., 'map[string]string' and 'map[string]Person'  ","version":"latest","tagName":"h3"},{"title":"2. Validation and Documentation Markers​","type":1,"pageTitle":"2. Simple Schema","url":"/docs/docs/concepts/simple-schema#2-validation-and-documentation-markers","content":" In addition to the type, fields can also have markers for validation, documentation and other purposes that are OpenAPISchema compatible.  For example to define a field that is required, has a default value and a description, you can define it as follows:  person: name: string | required=true default=&quot;Kylian Mbappé&quot; description=&quot;Name of the person&quot;   Currently supported markers include:  required=true: Field must be provideddefault=value: Default value if not provideddescription=&quot;...&quot;: Provides documentation for the fieldenum=&quot;value1,value2,...&quot;: Restricts to a set of values NOT IMPLEMENTEDminimum=value and maximum=value: For numeric constraints NOT IMPLEMENTED  ","version":"latest","tagName":"h3"},{"title":"3. Custom Types Definition​","type":1,"pageTitle":"2. Simple Schema","url":"/docs/docs/concepts/simple-schema#3-custom-types-definition","content":" Custom types are defined in the customTypes section, allowing for reusable complex structures. They can be referenced by name in the spec or status fields.  Example:  customTypes: ConfigType: logLevel: string | enum=&quot;debug,info,warn,error&quot; default=&quot;info&quot; maxConnections: integer | minimum=1 maximum=1000 spec: config: ConfigType | required=true   ","version":"latest","tagName":"h3"},{"title":"4. Status Field Definition​","type":1,"pageTitle":"2. Simple Schema","url":"/docs/docs/concepts/simple-schema#4-status-field-definition","content":" Status fields are defined similarly to spec fields and can include validation and documentation markers. However on top of that, status fields can also include value markers:  Value Marker NOT IMPLEMENTED​  value=&quot;${resource.status.field}&quot;: Specifies that this field's value should be dynamically obtained from another resource. The value is a CEL expression that is validated at ResourceGroup processing time and evaluated at runtime.  tip Note that the value marker is a symphony extension to the OpenAPISchema and is not part of the official OpenAPISchema specification.  Example:  status: url: string | value=&quot;${service.status.loadBalancer.ingress[0].hostname}&quot;   ","version":"latest","tagName":"h3"},{"title":"Default status fields​","type":1,"pageTitle":"2. Simple Schema","url":"/docs/docs/concepts/simple-schema#default-status-fields","content":" Symphony automatically injects two common fields into the status of all claims generated from ResourceGroups: conditions and state. These fields provide essential information about the current status of the claim and its associated resources.  tip conditions and state are reserved words in the status section. If a user defines these fields in their ResourceGroup's status schema, Symphony will override them with its own values.  ","version":"latest","tagName":"h2"},{"title":"1. Conditions​","type":1,"pageTitle":"2. Simple Schema","url":"/docs/docs/concepts/simple-schema#1-conditions","content":" The conditions field is an array of condition objects, each representing a specific aspect of the claim's state. Symphony automatically manages this field.  status: conditions: '[]condition' customTypes: condition: type: string status: string | enum=&quot;True,False,Unknown&quot; lastTransitionTime: string reason: string message: string   Common condition types include:  Ready: Indicates whether the claim is fully reconciled and operational.Progressing: Shows if the claim is in the process of reaching the desired state.Degraded: Signals that the claim is operational but not functioning optimally.Error: Indicates that an error has occurred during reconciliation.  ","version":"latest","tagName":"h3"},{"title":"2. State​","type":1,"pageTitle":"2. Simple Schema","url":"/docs/docs/concepts/simple-schema#2-state","content":" The state field provides a high-level summary of the claim's current status.  status: state: string | enum=&quot;Ready,Progressing,Degraded,Error,Terminating,Unknown&quot;   These default status fields are automatically added to every claim's status, providing a consistent way to check the health and state of resources across different ResourceGroups. ","version":"latest","tagName":"h3"},{"title":"API Reference","type":0,"sectionRef":"#","url":"/docs/api/out","content":"","keywords":"","version":"latest"},{"title":"Packages​","type":1,"pageTitle":"API Reference","url":"/docs/api/out#packages","content":" x.symphony.k8s.aws/v1alpha1  ","version":"latest","tagName":"h2"},{"title":"x.symphony.k8s.aws/v1alpha1​","type":1,"pageTitle":"API Reference","url":"/docs/api/out#xsymphonyk8sawsv1alpha1","content":" Package v1alpha1 contains API Schema definitions for the x v1alpha1 API group  ","version":"latest","tagName":"h2"},{"title":"Resource Types​","type":1,"pageTitle":"API Reference","url":"/docs/api/out#resource-types","content":" ResourceGroupResourceGroupList  Condition​  Condition is the common struct used by all CRDs managed by ACK service controllers to indicate terminal states of the CR and its backend AWS service API resource  Appears in:  ResourceGroupStatus  Field\tDescription\tDefault\tValidationtype ConditionType\tType is the type of the Condition status ConditionStatus\tStatus of the condition, one of True, False, Unknown. lastTransitionTime Time\tLast time the condition transitioned from one status to another. reason string\tThe reason for the condition's last transition. message string\tA human readable message indicating details about the transition. observedGeneration integer\tobservedGeneration represents the .metadata.generation that the condition was set based upon. For instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration is 9, the condition is out of date with respect to the current state of the instance. Minimum: 0   ConditionType​  Underlying type: string  Appears in:  Condition  Definition​  Appears in:  ResourceGroupSpec  Field\tDescription\tDefault\tValidationspec RawExtension status RawExtension types RawExtension validation string array   Resource​  Appears in:  ResourceGroupSpec  Field\tDescription\tDefault\tValidationname string Required: definition RawExtension Required:   ResourceGroup​  ResourceGroup is the Schema for the resourcegroups API  Appears in:  ResourceGroupList  Field\tDescription\tDefault\tValidationapiVersion string\tx.symphony.k8s.aws/v1alpha1 kind string\tResourceGroup kind string\tKind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds apiVersion string\tAPIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources metadata ObjectMeta\tRefer to Kubernetes API documentation for fields of metadata. spec ResourceGroupSpec status ResourceGroupStatus   ResourceGroupList​  ResourceGroupList contains a list of ResourceGroup  Field\tDescription\tDefault\tValidationapiVersion string\tx.symphony.k8s.aws/v1alpha1 kind string\tResourceGroupList kind string\tKind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds apiVersion string\tAPIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources metadata ListMeta\tRefer to Kubernetes API documentation for fields of metadata. items ResourceGroup array   ResourceGroupSpec​  ResourceGroupSpec defines the desired state of ResourceGroup  Appears in:  ResourceGroup  Field\tDescription\tDefault\tValidationkind string Required: apiVersion string Required: definition Definition Required: resources Resource array Optional:   ResourceGroupState​  Underlying type: string  Appears in:  ResourceGroupStatus  ResourceGroupStatus​  ResourceGroupStatus defines the observed state of ResourceGroup  Appears in:  ResourceGroup  Field\tDescription\tDefault\tValidationstate ResourceGroupState\tState is the state of the resourcegroup topologicalOrder string array\tTopologicalOrder is the topological order of the resourcegroup graph conditions Condition array\tConditions represent the latest available observations of an object's state  ","version":"latest","tagName":"h3"},{"title":"FAQ","type":0,"sectionRef":"#","url":"/docs/docs/faq","content":"FAQ","keywords":"","version":"latest"},{"title":"8. Managing State","type":0,"sectionRef":"#","url":"/docs/docs/concepts/managing-state","content":"8. Managing State Validation","keywords":"","version":"latest"},{"title":"1. ResourceGroups","type":0,"sectionRef":"#","url":"/docs/docs/concepts/resource-groups","content":"","keywords":"","version":"latest"},{"title":"What is a ResourceGroup?​","type":1,"pageTitle":"1. ResourceGroups","url":"/docs/docs/concepts/resource-groups#what-is-a-resourcegroup","content":" A ResourceGroup is a custom resource that serves as a blueprint for creating and managing a collection of Kubernetes resources. It allows you to:  Define multiple resources in a single, cohesive unitEstablish relationships and dependencies between resourcesCreate high-level abstractions of complex Kubernetes configurationsPromote reusability and consistency across your infrastructure  ","version":"latest","tagName":"h2"},{"title":"Anatomy of a ResourceGroup​","type":1,"pageTitle":"1. ResourceGroups","url":"/docs/docs/concepts/resource-groups#anatomy-of-a-resourcegroup","content":" A ResourceGroup, like any Kubernetes resource, consists of three main parts:  Metadata: Name, namespace, labels, etc.Spec: Defines the structure and properties of the ResourceGroupStatus: Reflects the current state of the ResourceGroup  The spec section of a ResourceGroup typically includes:  Parameters: Define the customizable aspects of the ResourceGroupResources: Specify the Kubernetes resources to be createdThe kind and apiVersion fields within the spec define the CRD that will be generated for this ResourceGroup. Here's a simple example of a ResourceGroup:  simple-web-app.yaml apiVersion: symphony.k8s.aws/v1 kind: ResourceGroup metadata: name: simple-web-app spec: kind: SimpleWebApp apiVersion: v1alpha1 parameters: appName: string image: string replicas: int resources: - name: deployment definition: apiVersion: apps/v1 kind: Deployment metadata: name: ${spec.appName}-deployment spec: replicas: ${spec.replicas} selector: matchLabels: app: ${spec.appName} template: metadata: labels: app: ${spec.appName} spec: containers: - name: ${spec.appName}-container image: ${spec.image} - name: service definition: apiVersion: v1 kind: Service metadata: name: ${spec.appName}-service spec: selector: app: ${spec.appName} ports: - port: 80 targetPort: 80   In this example, the ResourceGroup defines a simple web application with a Deployment and a Service. The appName, image, and replicas are parameters that can be set when instantiating this ResourceGroup.  ","version":"latest","tagName":"h2"},{"title":"ResourceGroup Processing​","type":1,"pageTitle":"1. ResourceGroups","url":"/docs/docs/concepts/resource-groups#resourcegroup-processing","content":" When a ResourceGroup is submitted to the Kubernetes API server, the Symphony controller processes it as follows:  Formal Verification: The controller performs a comprehensive analysis of the ResourceGroup definition. This includes: Syntax checking: Ensuring all fields are correctly formatted.Type checking: Validating that parameter types match their definitions.Semantic validation: Verifying that resource relationships and dependencies are logically sound.Dry-run validation: Simulating the creation of resources to detect potential issues. CRD Generation: The controller automatically generates a new Custom Resource Definition (CRD) based on the ResourceGroup's specification. This CRD represents the type for instances of this ResourceGroup. CRD Registration: It registers the newly generated CRD with the Kubernetes API server, making it available for use in the cluster. Micro-Controller Deployment: Symphony deploys a dedicated micro-controller for this ResourceGroup. This micro-controller will listen for &quot;claim&quot; events - instances of the CRD created in step 2. It will be responsible for managing the lifecycle of resources defined in the ResourceGroup for each claim. Status Update: The controller updates the status of the ResourceGroup to reflect that the corresponding CRD has been created and registered.  For example, given our simple-web-app ResourceGroup, the controller would create and register a CRD named SimpleWebApps (plural form of the ResourceGroup name). This CRD defines the structure for creating instances of the web application with customizable parameters. The deployed micro-controller would then manage all SimpleWebApps instances, creating and managing the associated Deployments and Services as defined in the ResourceGroup.  The Symphony controller continues to monitor the ResourceGroup for any changes, updating the corresponding CRD and micro-controller as necessary.  ","version":"latest","tagName":"h2"},{"title":"ResourceGroup Claim Example​","type":1,"pageTitle":"1. ResourceGroups","url":"/docs/docs/concepts/resource-groups#resourcegroup-claim-example","content":" After the ResourceGroup is processed, users can create instances of it. Here's an example of how a claim for the SimpleWebApp might look:  my-web-app-claim.yaml apiVersion: symphony.k8s.aws/v1alpha1 kind: SimpleWebApp metadata: name: my-web-app spec: appName: awesome-app image: nginx:latest replicas: 3   In the next section, we'll explore the parameters and resources sections of a ResourceGroup in more detail. ","version":"latest","tagName":"h2"},{"title":"4. Collections","type":0,"sectionRef":"#","url":"/docs/docs/concepts/collections","content":"","keywords":"","version":"latest"},{"title":"What are Collections?​","type":1,"pageTitle":"4. Collections","url":"/docs/docs/concepts/collections#what-are-collections","content":" A collection is a special field in a ResourceGroup that defines a template for creating multiple similar resources. Key features of collections include:  Dynamic creation of resources based on user inputConsistent structure across multiple resource instancesSimplified management of groups of related resources  ","version":"latest","tagName":"h2"},{"title":"Defining a Collection​","type":1,"pageTitle":"4. Collections","url":"/docs/docs/concepts/collections#defining-a-collection","content":" Here's an example of how to define a collection in a ResourceGroup:  apiVersion: symphony.k8s.aws/v1alpha1 kind: ResourceGroup metadata: name: ReplicaSet.x.symphony.k8s.aws spec: kind: ReplicaSet apiVersion: v1alpha1 parameters: spec: clusterName: string podCount: integer | minimum=1 maximum=5 resources: - name: nodesCollection collection: index: ${range(0, spec.podCount)} definition: apiVersion: v1 kind: Pod metadata: name: ${clusterName}-node-${index} spec: containers: - name: db image: nginx:latest   In this example, nodes is a collection that will create multiple Pod resources based on the podCount parameter.  ","version":"latest","tagName":"h2"},{"title":"Key Concepts​","type":1,"pageTitle":"4. Collections","url":"/docs/docs/concepts/collections#key-concepts","content":" index: Specifies the range of values for the collection, allowing for dynamic creation of multiple resources. definition: Defines the structure of each resource instance in the collection. The ${index} variable ensures uniqueness of each resource.  ","version":"latest","tagName":"h2"},{"title":"Using Collections in Claims​","type":1,"pageTitle":"4. Collections","url":"/docs/docs/concepts/collections#using-collections-in-claims","content":" When creating a claim, users can specify the count for the collection:  apiVersion: symphony.k8s.aws/v1alpha1 kind: ReplicaSet metadata: name: my-db-cluster spec: clusterName: production-db podCount: 3   This claim will result in the creation of three Postgres Pods namedproduction-db-node-0, production-db-node-1, and production-db-node-2.  ","version":"latest","tagName":"h2"},{"title":"Deployment Strategy​","type":1,"pageTitle":"4. Collections","url":"/docs/docs/concepts/collections#deployment-strategy","content":" While defining collections is straightforward, it's essential to consider the deployment strategy for managing multiple resources. Symphony provides flexibility in managing collections, allowing users to define how resources are created, updated, and deleted based on the desired state.  Symphony provide two strategies for managing collections:  RollingUpdate: Creates, updates and deletes resources in an incremental manner, ensuring that only one resource is updated at a time.ParallelUpdate: Creates, updates and deletes resources in parallel, allowing for faster deployment of multiple resources.  For examples you can add the following to the spec section of the ResourceGroup:  spec: kind: ReplicaSet apiVersion: v1alpha1 parameters: spec: clusterName: string podCount: integer | minimum=1 maximum=5 resources: - name: nodes strategy: RollingUpdate collection: index: ${range(0, spec.podCount)} definition: apiVersion: v1 kind: Pod metadata: name: ${clusterName}-node-${index} spec: containers: - name: db image: nginx:latest  ","version":"latest","tagName":"h2"},{"title":"DeploymentService","type":0,"sectionRef":"#","url":"/docs/examples/deploymentservice","content":"DeploymentService deploymentservice-rg.yaml apiVersion: x.symphony.k8s.aws/v1alpha1 kind: ResourceGroup metadata: name: deploymentservice.x.symphony.k8s.aws spec: apiVersion: v1alpha1 kind: DeploymentService definition: spec: name: string resources: - name: deployment definition: apiVersion: apps/v1 kind: Deployment metadata: name: ${spec.name} spec: replicas: 1 selector: matchLabels: app: deployment template: metadata: labels: app: deployment spec: containers: - name: ${spec.name}-deployment image: nginx ports: - containerPort: 80 - name: service definition: apiVersion: v1 kind: Service metadata: name: ${spec.name} spec: selector: app: deployment ports: - protocol: TCP port: 80 targetPort: 80 ","keywords":"","version":"latest"},{"title":"Empty ResourceGroup","type":0,"sectionRef":"#","url":"/docs/examples/empty","content":"Empty ResourceGroup no-resources-rg.yaml apiVersion: x.symphony.k8s.aws/v1alpha1 kind: ResourceGroup metadata: name: noop.x.symphony.k8s.aws spec: apiVersion: v1alpha1 kind: Noop definition: spec: name: string | required=true resources: [] ","keywords":"","version":"latest"},{"title":"3. Claims","type":0,"sectionRef":"#","url":"/docs/docs/concepts/claims","content":"","keywords":"","version":"latest"},{"title":"What is a Claim?​","type":1,"pageTitle":"3. Claims","url":"/docs/docs/concepts/claims#what-is-a-claim","content":" A Claim is a Kubernetes custom resource that:  References a specific ResourceGroupProvides values for the parameters defined in the ResourceGroupRepresents the desired state of a set of Kubernetes resources  ","version":"latest","tagName":"h2"},{"title":"Anatomy of a Claim​","type":1,"pageTitle":"3. Claims","url":"/docs/docs/concepts/claims#anatomy-of-a-claim","content":" Here's an example of a Claim for a WebApplication ResourceGroup:  apiVersion: symphony.k8s.aws/v1alpha1 kind: WebApplication metadata: name: my-web-app spec: name: awesome-app replicas: 3 image: nginx:latest ports: - port: 80 targetPort: 8080 env: DB_HOST: mydb.example.com LOG_LEVEL: debug   tip The spec fields of a Claim correspond to the parameters defined in the ResourceGroup.  ","version":"latest","tagName":"h2"},{"title":"The reconciliation loop​","type":1,"pageTitle":"3. Claims","url":"/docs/docs/concepts/claims#the-reconciliation-loop","content":" Symphony manages Claims through a continuous reconciliation process:  Desired state detection: Symphony observes the Claim, which represents the desired state of resources.Current state assessment: Symphony talks to the api-server and checks the current state of resources in the cluster related to the Claim.Difference identification: Any differences between the desired state (Claim) and the current state are identified.State Reconciliation: Symphony takes necessary actions to align the current state with the desired state. This may involve creating, updating, or deleting resources as needed.Status Updates: The Claim's status is updated to reflect the current state of reconciliation and any issues encountered.Continuous Loop: This process repeats regularly, ensuring the cluster state always converges towards the desired state defined in the Claim.  ","version":"latest","tagName":"h2"},{"title":"Advantages of declarative management [need better title]​","type":1,"pageTitle":"3. Claims","url":"/docs/docs/concepts/claims#advantages-of-declarative-management-need-better-title","content":" Declarative Management: Users define what they want, not how to get there.Self-healing: The system continuously works to maintain the desired state.Idempotency: The same Claim always results in the same end state, regardless of the current state.Abstraction: Complex resource relationships are managed behind the scenes.Consistency: All resources for an application are managed as a unit.Auditability: The Claim serves as a single source of truth for the application's desired state.  Best Practices Treat claims as declarative definitions of your application's desired state. Use version control for your Claims to track changes over time.Leverage labels and annotations in Claims for organization and filtering.Regularly review Claims to ensure they reflect current requirements.Use Symphony's dry-run feature to preview reconciliation actions before applying changes to Claims.Monitor Claim statuses to understand the current state of your applications.  ","version":"latest","tagName":"h2"},{"title":"Common Status Fields​","type":1,"pageTitle":"3. Claims","url":"/docs/docs/concepts/claims#common-status-fields","content":" Symphony automatically injects two common fields into the status of all claims:Conditions and State. These fields provide crucial information about the current status of the claim and its associated resources.  ","version":"latest","tagName":"h2"},{"title":"1. Conditions​","type":1,"pageTitle":"3. Claims","url":"/docs/docs/concepts/claims#1-conditions","content":" Conditions are a standard Kubernetes concept that Symphony leverages to provide detailed status information. Each condition represents a specific aspect of the claim's state. Common conditions include:  Ready: Indicates whether the claim is fully reconciled and operational.Progressing: Shows if the claim is in the process of reaching the desired state.Degraded: Signals that the claim is operational but not functioning optimally.Error: Indicates that an error has occurred during reconciliation.  Each condition typically includes the following properties:  Type: The name of the condition (e.g., &quot;Ready&quot;).Status: Either &quot;True&quot;, &quot;False&quot;, or &quot;Unknown&quot;.LastTransitionTime: When the condition last changed.Reason: A brief, machine-readable explanation for the condition's state.Message: A human-readable description of the condition.  Example:  status: conditions: - type: Ready status: &quot;True&quot; lastTransitionTime: &quot;2024-07-23T01:01:59Z&quot; reason: ResourcesAvailable message: &quot;All resources are available and configured correctly&quot;   ","version":"latest","tagName":"h3"},{"title":"2. State​","type":1,"pageTitle":"3. Claims","url":"/docs/docs/concepts/claims#2-state","content":" The State field provides a high-level summary of the claim's current status. It is typically one of the following values:  Pending: The claim is being processed, but resources are not yet fully created or configured.Running: All resources are created and the claim is operational.Failed: An error occurred and the claim could not be fully reconciled.Terminating: The claim is in the process of being deleted.Degraded: The claim is operational but not functioning optimally.Unknown: The claim's status cannot be determined.  Example:  status: state: Running   These common status fields provide users with a consistent and informative way to check the health and state of their claims across different ResourceGroups. They are essential for monitoring, troubleshooting, and automating operations based on the status of Symphony-managed resources. ","version":"latest","tagName":"h3"},{"title":"What is Symphony?","type":0,"sectionRef":"#","url":"/docs/docs/overview","content":"","keywords":"","version":"latest"},{"title":"Developer interface​","type":1,"pageTitle":"What is Symphony?","url":"/docs/docs/overview#developer-interface","content":" When the end user applies a YAML spec to the cluster using the Custom API, the API creates a set of resources within the cluster. These resources can include both native Kubernetes resources and any Custom Resource Definitions (CRDs)installed in the cluster. Some of these resources may create additional resources outside of your cluster.  As depicted in the following diagram, the Developers call the Custom API, which creates resources such as the Deployment, Ingress, ServiceAccount, Prometheus Monitor,Role, Policy, and Amazon S3. This allows the Developers to easily manage and deploy their applications in a standardized and streamlined manner.  Fugure 1: End user interface - Custom API  ","version":"latest","tagName":"h3"},{"title":"ResourceGroup​","type":1,"pageTitle":"What is Symphony?","url":"/docs/docs/overview#resourcegroup","content":" When you install Symphony in your cluster, it installs a Custom Resource Definition (CRD) called ResourceGroup (RG). The Platform, Security, and Compliance teams, can collaborate to create custom APIs by defining Custom Resources for the ResourceGroup CRD.  In the depicted example, the Platform Team has created an Application Stack RG that encapsulates the necessary resources, along with any additional logic, abstractions, and security best practices. This empowers the Developers to interact with an API when managing their applications. The Developers no longer need to directly manage the underlying infrastructure complexities, as the custom API handles the deployment and configuration of the required resources.  Fugure 2: ResourceGroup (RG) - Platform Team Interface  ","version":"latest","tagName":"h3"},{"title":"ResourceGroup Instance​","type":1,"pageTitle":"What is Symphony?","url":"/docs/docs/overview#resourcegroup-instance","content":" Developer teams can create multiple instances of the Application Stack, each tailored to their specific requirements. As shown, Dev Team A and Dev Team B have both instantiated their own Application Stacks. While the underlying resources are similar, Dev Team A has chosen to expose their service externally, leveraging the Ingress option, while Dev Team B has opted to keep their service internal to the cluster. This flexibility allows each development team to customize their application stack based on their specific requirements.  Fugure 3: ResourceGroup Instance (RGI)  Why Symphony?  ","version":"latest","tagName":"h3"},{"title":"Manage any group of resources as one unit​","type":1,"pageTitle":"What is Symphony?","url":"/docs/docs/overview#manage-any-group-of-resources-as-one-unit","content":" Using Symphony, the Platform Team can enable Developer teams to quickly deploy and manage applications and their dependencies as one unit, handling the entire lifecycle from deployment to maintenance. The new APIs integrate seamlessly with developers' existing CD tools, preserving familiar processes and interfaces to simplify adoption.  ","version":"latest","tagName":"h3"},{"title":"Collaborate​","type":1,"pageTitle":"What is Symphony?","url":"/docs/docs/overview#collaborate","content":" Transform Kubernetes into your unified platform configuration framework using Symphony. Platform, Compliance, and Security teams work together to develop APIs that standardize and streamline configurations, making it easier for Developer teams to adopt secure, compliant practices. This collaboration lets you build your organizational standards directly into the APIs, ensuring every application deployment aligns with security and compliance requirements without adding complexity for developers.  ","version":"latest","tagName":"h3"},{"title":"Standardize​","type":1,"pageTitle":"What is Symphony?","url":"/docs/docs/overview#standardize","content":" By creating unified APIs, you can define and enforce best practices across all environments, ensuring every application meets organizational requirements and achieving consistency across deployment environments.  Community  We welcome questions, suggestions, and contributions from the community! To get involved, check out ourcontributing guide. For bugs or feature requests, feel free to submit an issue. You’re also invited to join our community meeting. ","version":"latest","tagName":"h3"},{"title":"Installing Symphony","type":0,"sectionRef":"#","url":"/docs/docs/getting-started/Installation","content":"","keywords":"","version":"latest"},{"title":"Prerequisites​","type":1,"pageTitle":"Installing Symphony","url":"/docs/docs/getting-started/Installation#prerequisites","content":" Before you begin, ensure you have the following:  Access to an AWS accountAWS CLI installed and configuredHelm 3.x installedkubectl installed and configured to interact with your Kubernetes clusterNecessary permissions to pull images from Amazon ECR  ","version":"latest","tagName":"h2"},{"title":"Installation Steps​","type":1,"pageTitle":"Installing Symphony","url":"/docs/docs/getting-started/Installation#installation-steps","content":" Getting Alpha Access If you are reading this, you are installing a pre-alpha version of symphony, that requires special authorization from the EKS service team. If you believe that you don't have the necessary permissions, please reach out to Lukonde Mwilalukondef@amazon.com  ","version":"latest","tagName":"h2"},{"title":"1. Authenticate with Amazon ECR​","type":1,"pageTitle":"Installing Symphony","url":"/docs/docs/getting-started/Installation#1-authenticate-with-amazon-ecr","content":" First, authenticate your Helm client with the Amazon Elastic Container Registry (ECR) that hosts the Symphony pre-alpha chart. Run the following command:  aws ecr get-login-password --region us-west-2 | helm registry login \\ --username AWS --password-stdin 095708837592.dkr.ecr.us-west-2.amazonaws.com   ","version":"latest","tagName":"h3"},{"title":"2. Install Symphony using Helm​","type":1,"pageTitle":"Installing Symphony","url":"/docs/docs/getting-started/Installation#2-install-symphony-using-helm","content":" Once authenticated, install Symphony using the Helm chart:  export SYMPHONY_VERSION=0.0.7 # TODO(a-hilaly): replace with curl-github-fu to get the latest version # export SYMPHONY_VERSION=$(curl -s https://api.github.com/repos/aws-controllers-k8s/private-symphony/releases/latest | grep '&quot;tag_name&quot;:' | sed -E 's/.*&quot;([^&quot;]+)&quot;.*/\\1/') helm install --version=${SYMPHONY_VERSION} -n symphony \\ symphony oci://095708837592.dkr.ecr.us-west-2.amazonaws.com/symphony-chart \\ --version=${SYMPHONY_VERSION}   ","version":"latest","tagName":"h3"},{"title":"Verifying the Installation​","type":1,"pageTitle":"Installing Symphony","url":"/docs/docs/getting-started/Installation#verifying-the-installation","content":" After running the installation command, verify that Symphony has been installed correctly:  Check the Helm release: helm list You should see the &quot;symphony&quot; release listed. Check the Symphony pods: kubectl get pods You should see Symphony-related pods running.  ","version":"latest","tagName":"h2"},{"title":"Upgrading Symphony​","type":1,"pageTitle":"Installing Symphony","url":"/docs/docs/getting-started/Installation#upgrading-symphony","content":" To upgrade to a newer version of Symphony, use the Helm upgrade command:  export SYMPHONY_VERSION=&lt;new-version&gt; helm upgrade -n symphony \\ symphony oci://095708837592.dkr.ecr.us-west-2.amazonaws.com/symphony-chart \\ --version=${SYMPHONY_VERSION}   Replace &lt;new-version&gt; with the version you want to upgrade to.  info Helm does not support updating CRDs, so you may need to manually update or remove symphony related CRDs. For more information, refer to the Helm documentation.  ","version":"latest","tagName":"h2"},{"title":"Uninstalling Symphony​","type":1,"pageTitle":"Installing Symphony","url":"/docs/docs/getting-started/Installation#uninstalling-symphony","content":" To uninstall Symphony, use the following command:  helm uninstall symphony   Keep in mind that this command will remove all Symphony resources from your cluster, except for the ResourceGroup CRD and any other custom resources you may have created. ","version":"latest","tagName":"h2"},{"title":"Deploy a Resource Group","type":0,"sectionRef":"#","url":"/docs/docs/getting-started/deploy-a-resource-group","content":"","keywords":"","version":"latest"},{"title":"Prerequisites​","type":1,"pageTitle":"Deploy a Resource Group","url":"/docs/docs/getting-started/deploy-a-resource-group#prerequisites","content":" Before you begin, ensure you have the following:  Installed Symphony on your Kubernetes clusterA ResourceGroup manifest file  For this examole, we'll use a simple ResourceGroup that defines a Deployment and a Service. Here's an example of a ResourceGroup manifest file:  deploymentservice-rg.yaml apiVersion: x.symphony.k8s.aws/v1alpha1 kind: ResourceGroup metadata: name: deploymentservice.x.symphony.k8s.aws spec: apiVersion: v1alpha1 kind: DeploymentService definition: spec: name: string resources: - name: deployment definition: apiVersion: apps/v1 kind: Deployment metadata: name: ${spec.name} spec: replicas: 1 selector: matchLabels: app: deployment template: metadata: labels: app: deployment spec: containers: - name: ${spec.name}-deployment image: nginx ports: - containerPort: 80 - name: service definition: apiVersion: v1 kind: Service metadata: name: ${spec.name} spec: selector: app: deployment ports: - protocol: TCP port: 80 targetPort: 80   ","version":"latest","tagName":"h2"},{"title":"Steps​","type":1,"pageTitle":"Deploy a Resource Group","url":"/docs/docs/getting-started/deploy-a-resource-group#steps","content":" Create a ResourceGroup manifest file: Create a new file with the ResourceGroup definition. You can use the example above as a template. Deploy the ResourceGroup: Use the kubectl command to deploy the ResourceGroup to your Kubernetes cluster: kubectl apply -f deploymentservice-rg.yaml Verify the resources: Check the status of the resources created by the ResourceGroup using the kubectl command: kubectl get rg You should see something like this: NAME APIVERSION KIND STATE AGE deploymentservice.x.symphony.k8s.aws v1alpha1 DeploymentService ACTIVE 16m Install a resource group claim: Create a claim for the resource group you just deployed. Claims are used to define the desired state of the resources in the ResourceGroup. Here's an example of a Claim for the EKSCluster ResourceGroup: apiVersion: x.symphony.k8s.aws/v1alpha1 kind: DeploymentService metadata: name: my-deployment-and-service spec: name: app1 The spec fields of a Claim correspond to the parameters defined in the ResourceGroup. ","version":"latest","tagName":"h2"},{"title":"DeploymentDBInstance","type":0,"sectionRef":"#","url":"/docs/examples/deploymentdbinstance","content":"DeploymentDBInstance deploymentdbinstance-rg.yaml apiVersion: x.symphony.k8s/v1alpha1 kind: ResourceGroup metadata: name: deploymentandawspostgres.x.symphony.k8s spec: apiVersion: v1alpha1 kind: DeploymentAndAWSPostgres # CRD Definition definition: spec: applicationName: string image: string location: string # Resources resources: - name: dbinstance definition: apiVersion: rds.saervices.k8s.aws/v1alpha1 kind: DBInstance metadata: name: ${spec.applicationName}-dbinstance spec: # need to specify the required fields (e.g masterUsername, masterPassword) engine: postgres dbInstanceIdentifier: ${spec.applicationName}-dbinstance allocatedStorage: 20 dbInstanceClass: db.t3.micro - name: pod definition: apiVersion: v1 kind: Pod metadata: name: ${spec.applicationName}-pod spec: containers: - name: container1 image: ${spec.image} env: - name: POSTGRESS_ENDPOINT value: ${dbinstance.status.endpoint.address} ","keywords":"","version":"latest"},{"title":"EKSCluster","type":0,"sectionRef":"#","url":"/docs/examples/ekscluster","content":"EKSCluster ekscluster-rg.yaml apiVersion: x.symphony.k8s.aws/v1alpha1 kind: ResourceGroup metadata: name: ekscluster.x.symphony.k8s.aws spec: # CRD Definition apiVersion: v1alpha1 kind: EKSCluster definition: spec: name: string version: string numNodes: integer # resources resources: - name: clusterVPC definition: apiVersion: ec2.services.k8s.aws/v1alpha1 kind: VPC metadata: name: cluster-vpc-${spec.name} spec: cidrBlocks: - 192.168.0.0/16 enableDNSHostnames: false enableDNSSupport: true - name: subnetAZA definition: apiVersion: ec2.services.k8s.aws/v1alpha1 kind: Subnet metadata: name: cluster-subnet-a-${spec.name} spec: availabilityZone: us-west-2a cidrBlock: 192.168.0.0/18 vpcID: ${clusterVPC.status.vpcID} - name: securityGroup definition: apiVersion: ec2.services.k8s.aws/v1alpha1 kind: SecurityGroup metadata: name: cluster-security-group-${spec.name} spec: vpcID: ${clusterVPC.status.vpcID} name: my-eks-cluster-sg-${spec.name} description: something something - name: subnetAZB definition: apiVersion: ec2.services.k8s.aws/v1alpha1 kind: Subnet metadata: name: cluster-subnet-b-${spec.name} spec: availabilityZone: us-west-2b cidrBlock: 192.168.64.0/18 vpcID: ${clusterVPC.status.vpcID} - name: clusterRole definition: apiVersion: iam.services.k8s.aws/v1alpha1 kind: Role metadata: name: cluster-role-${spec.name} spec: name: cluster-role-${spec.name} policies: - arn:aws:iam::aws:policy/AmazonEKSClusterPolicy assumeRolePolicyDocument: | { &quot;Version&quot;: &quot;2012-10-17&quot;, &quot;Statement&quot;: [ { &quot;Effect&quot;: &quot;Allow&quot;, &quot;Principal&quot;: { &quot;Service&quot;: &quot;eks.amazonaws.com&quot; }, &quot;Action&quot;: &quot;sts:AssumeRole&quot; } ] } - name: nodeRole definition: apiVersion: iam.services.k8s.aws/v1alpha1 kind: Role metadata: name: cluster-node-role-${spec.name} spec: name: cluster-node-role-${spec.name} policies: - arn:aws:iam::aws:policy/AmazonEKSWorkerNodePolicy - arn:aws:iam::aws:policy/AmazonEC2ContainerRegistryReadOnly - arn:aws:iam::aws:policy/AmazonEKS_CNI_Policy assumeRolePolicyDocument: | { &quot;Version&quot;: &quot;2012-10-17&quot;, &quot;Statement&quot;: [ { &quot;Effect&quot;: &quot;Allow&quot;, &quot;Principal&quot;: { &quot;Service&quot;: &quot;ec2.amazonaws.com&quot; }, &quot;Action&quot;: &quot;sts:AssumeRole&quot; } ] } - name: cluster definition: apiVersion: eks.services.k8s.aws/v1alpha1 kind: Cluster metadata: name: cluster-${spec.name} spec: name: cluster-${spec.name} roleARN: ${clusterRole.status.ackResourceMetadata.arn} version: ${spec.version} resourcesVPCConfig: subnetIDs: - ${subnetAZA.status.subnetID} - ${subnetAZB.status.subnetID} - name: nodegroup definition: apiVersion: eks.services.k8s.aws/v1alpha1 kind: Nodegroup metadata: name: nodegroup-${spec.name} spec: name: nodegroup-${spec.name} clusterName: cluster-${spec.name} subnets: - ${subnetAZA.status.subnetID} - ${subnetAZB.status.subnetID} nodeRole: ${nodeRole.status.ackResourceMetadata.arn} updateConfig: maxUnavailable: 1 scalingConfig: minSize: ${spec.numNodes} maxSize: ${spec.numNodes} desiredSize: ${spec.numNodes} ","keywords":"","version":"latest"}],"options":{"id":"default"}}